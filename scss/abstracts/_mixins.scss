/* 
This file contains SCSS mixins sourced from the Bootstrap framework.
Source: https://github.com/twbs/bootstrap/tree/main/scss/mixins
These mixins are used in accordance with Bootstrap's open-source license (MIT).
Modifications may have been made to the original mixins.
*/
@use 'sass:meta';
@use 'sass:math';
@use 'sass:map';
@use 'sass:list';
@use 'sass:string';
@use 'sass:selector';
@use 'functions' as *;
@use 'variables' as *;

@mixin transition($transition...) {
  @if list.length($transition) == 0 {
    $transition: $transition-base;
  }

  @if list.length($transition) > 1 {
    @each $value in $transition {
      @if $value == null or $value == none {
        @warn "The keyword 'none' or 'null' must be used as a single argument.";
      }
    }
  }

  @if $enable-transitions {
    @if list.nth($transition, 1) != null {
      transition: $transition;
    }

    @if $enable-reduced-motion and
      list.nth($transition, 1) !=
      null and
      list.nth($transition, 1) !=
      none
    {
      @media (prefers-reduced-motion: reduce) {
        transition: none;
      }
    }
  }
}

// media query

@mixin mq($breakpoint, $config: ()) {
  $INTERACTION-FINE: fine;
  $INTERACTION-COARSE: coarse;
  $INTERACTION-NONE: none;

  $has-media-hover: false;
  $_core-config: (
    grid-breakpoints: $grid-breakpoints,
    interaction: $INTERACTION-NONE,
  );

  $_config: map.merge($_core-config, $config);

  $_grid-breakpoints: map.get($_config, grid-breakpoints);
  $_interaction: map.get($_config, interaction);

  // @debug $_grid-breakpoints;
  // @debug breakpoint $breakpoint;
  // @debug bool $breakpoint == xs;
  // @debug has-key map.has-key($_grid-breakpoints, $breakpoint);
  // @debug has-key and is xs (map.has-key($_grid-breakpoints, $breakpoint) and $breakpoint == xs);
  // @debug second ifelse map.get($_grid-breakpoints, $breakpoint);

  @if ($breakpoint == xs) {
    // do nothing
    @debug '**NOTE**: Skipping breakpoint xs in @mixin mq';
  } @else if map.has-key($_grid-breakpoints, $breakpoint) {
    $breakpoint-size: map.get($_grid-breakpoints, $breakpoint);

    @if ($_interaction == $INTERACTION-FINE) {
      @media screen and (min-width: $breakpoint-size) and (hover: hover) and (pointer: fine) {
        @content;
      }
    } @else if ($_interaction == $INTERACTION-COARSE) {
      @media screen and (min-width: $breakpoint-size) and (hover: none) and (pointer: coarse) {
        @content;
      }
    } @else {
      @media screen and (min-width: $breakpoint-size) {
        @content;
      }
    }
  } @else {
    @error 'the keyword #{$breakpoint} is not in the $breakpoints map';
  }
}

// Mixin: Media query for hover-capable devices at a specific breakpoint
// - Includes (hover: hover) and (pointer: fine) for precision
// - Falls back to a regular media query if $has-media-hover is false
// - Throws an error if the breakpoint is not defined in $grid-breakpoints
@mixin mq-hover-device($breakpoint) {
  @include mq($breakpoint, true);
}

@mixin respond-min($breakpoint) {
  @media (min-width: #{$breakpoint}px) {
    @content;
  }
}

@mixin make-container() {
  width: 100%;
  padding-inline: var(--container-padding, 12px);
  margin-inline: auto;
}

@mixin make-container-fluid-max($max-width) {
  max-width: $max-width;
  padding-inline: var(--container-padding, 12px);
  margin-inline: auto;
}

@mixin media-breakpoint-up($name, $breakpoints: $grid-breakpoints) {
  $min: breakpoint-min($name, $breakpoints);

  // @debug min $min;
  @if $min {
    @media screen and (min-width: $min) {
      // @debug in media $min;

      @content;
    }
  } @else {
    // @debug kein media;

    @content;
  }
}

@mixin container-breakpoint-up($name, $breakpoints: $grid-breakpoints) {
  $min: breakpoint-min($name, $breakpoints);

  // @debug min $min;
  @if $min {
    @container (width > #{$min}) {
      @content;
    }
  }
}

// Bootstrap grid system
@mixin row-cols($count) {
  > * {
    flex: 0 0 auto;
    width: math.percentage(math.div(1, $count));
  }
}

@mixin make-row($gutter: $grid-gutter-width) {
  --#{$bs-prefix}gutter-x: #{$gutter};
  --#{$bs-prefix}gutter-y: 0;
  display: flex;
  flex-wrap: wrap;
  margin-top: calc(-1 * var(--#{$bs-prefix}gutter-y));
  margin-right: calc(-0.5 * var(--#{$bs-prefix}gutter-x));
  margin-left: calc(-0.5 * var(--#{$bs-prefix}gutter-x));
}

@mixin make-col-ready() {
  // Add box sizing if only the grid is loaded
  box-sizing: if(
    meta.variable-exists(include-column-box-sizing) and $include-column-box-sizing,
    border-box,
    null
  );
  // Prevent columns from becoming too narrow when at smaller grid tiers by
  // always setting `width: 100%;`. This works because we set the width
  // later on to override this initial width.
  flex-shrink: 0;
  width: 100%;
  max-width: 100%; // Prevent `.col-auto`, `.col` (& responsive variants) from breaking out the grid
  padding-right: calc(
    var(--#{$bs-prefix}gutter-x) * 0.5
  ); // stylelint-disable-line function-disallowed-list
  padding-left: calc(
    var(--#{$bs-prefix}gutter-x) * 0.5
  ); // stylelint-disable-line function-disallowed-list
  margin-top: var(--#{$bs-prefix}gutter-y);
}

@mixin make-col($size: false, $columns: $grid-columns) {
  @if $size {
    flex: 0 0 auto;
    width: math.percentage(math.div($size, $columns));
  } @else {
    flex: 1 1 0;
    max-width: 100%;
  }
}

@mixin make-col-auto() {
  flex: 0 0 auto;
  width: auto;
}

@mixin make-col-offset($size, $columns: $grid-columns) {
  $num: math.div($size, $columns);
  margin-left: if($num == 0, 0, math.percentage($num));
}

@mixin make-grid-columns(
  $columns: $grid-columns,
  $gutter: $grid-gutter-width,
  $breakpoints: $grid-breakpoints
) {
  @each $breakpoint in map.keys($breakpoints) {
    $infix: breakpoint-infix($breakpoint, $breakpoints);

    @include media-breakpoint-up($breakpoint, $breakpoints) {
      // Provide basic `.col-{bp}` classes for equal-width flexbox columns
      .col#{$infix} {
        flex: 1 0 0%; // Flexbugs #4: https://github.com/philipwalton/flexbugs#flexbug-4
      }

      .row-cols#{$infix}-auto > * {
        @include make-col-auto();
      }

      @if $grid-row-columns > 0 {
        @for $i from 1 through $grid-row-columns {
          .row-cols#{$infix}-#{$i} {
            @include row-cols($i);
          }
        }
      }

      .col#{$infix}-auto {
        @include make-col-auto();
      }

      @if $columns > 0 {
        @for $i from 1 through $columns {
          .col#{$infix}-#{$i} {
            @include make-col($i, $columns);
          }
        }

        // `$columns - 1` because offsetting by the width of an entire row isn't possible
        @for $i from 0 through ($columns - 1) {
          @if not($infix == '' and $i == 0) {
            // Avoid emitting useless .offset-0
            .offset#{$infix}-#{$i} {
              @include make-col-offset($i, $columns);
            }
          }
        }
      }

      // Gutters
      //
      // Make use of `.g-*`, `.gx-*` or `.gy-*` utilities to change spacing between the columns.
      @if ($enable-gutters) {
        @each $key, $value in $sizes-regular {
          .g#{$infix}-#{$key},
          .gx#{$infix}-#{$key} {
            --#{$bs-prefix}gutter-x: #{$value};
          }

          .g#{$infix}-#{$key},
          .gy#{$infix}-#{$key} {
            --#{$bs-prefix}gutter-y: #{$value};
          }
        }
      }
    }
  }
}

@mixin make-cssgrid($columns: $grid-columns, $breakpoints: $grid-breakpoints) {
  @each $breakpoint in map-keys($breakpoints) {
    $infix: breakpoint($breakpoint, $breakpoints);

    @include media-breakpoint-up($breakpoint, $breakpoints) {
      @if $columns > 0 {
        @for $i from 1 through $columns {
          .g-col#{$infix}-#{$i} {
            grid-column: auto / span $i;
          }
        }

        // Start with `1` because `0` is an invalid value.
        // Ends with `$columns - 1` because offsetting by the width of an entire row isn't possible.
        @for $i from 1 through ($columns - 1) {
          .g-start#{$infix}-#{$i} {
            grid-column-start: $i;
          }
        }
      }
    }
  }
}

@mixin generate-utility($utility, $bp: '', $breakpoint-key, $key, $is-rfs-media-query: false) {
  $values: map.get($utility, values);
  $selected-function: if(map.has-key($utility, function), map.get($utility, function), 'default');

  // Check if the list is not empty before accessing the first element
  @if list.length($values) > 0 and $values != null {
    // If the values are a list or string, convert it into a map
    @if meta.type-of($values) == 'string' or meta.type-of(list.nth($values, 1)) != 'list' {
      $values: list.zip($values, $values);
    }
  }

  // @debug values $values;
  // @debug meta.type-of($values);

  $is-important: if(map.get($utility, important), !important, null);

  $required-property: if(
    map.has-key($utility, required-property),
    map.get($utility, required-property),
    null
  );
  $property: map.get($utility, property);

  $custom-property-value: if(
    map.has-key($utility, custom-property-value),
    map.get($utility, custom-property-value),
    null
  );

  // @debug $custom-property-value;
  $class: map.get($utility, class);

  // Multiple properties are possible, for example with vertical or horizontal margins or paddings
  // @debug properties before $properties;

  @if meta.type-of($property) == 'string' {
    $property: list.append((), $property);

    // @debug properties inside $properties;
  }

  // @debug properties after $properties;

  $local-vars: map.get($utility, local-vars);
  $is-rtl: map.get($utility, rtl);
  $custom-property-name: map.get($utility, custom-property-name);

  @debug cpn $custom-property-name;
  $nested-selectors: if(
    map.has-key($utility, complex-selectors),
    map.get($utility, complex-selectors),
    null
  );
  $complex-selectors: if(
    map.has-key($utility, complex-selectors),
    map.get($utility, complex-selectors),
    null
  );
  $state: map.get($utility, state);
  $custom-property-prefix: map.get($utility, custom-property-prefix);
  $css-variable-name: map.get($utility, css-variable-name);
  $media: map.get($utility, media);

  $responsive-custom-property-value: map.get($utility, responsive-custom-property-value);
  $configuration-map: (
    property: $property,
    responsive-custom-property: $responsive-custom-property-value,
    values: $values,
    important: $is-important,
    required-property: $required-property,
    breakpoint: $bp,
    breakpoint-key: $breakpoint-key,
    class: $class,
    key: $key,
    custom-property-name: $custom-property-name,
    custom-property-value: $custom-property-value,
    custom-property-prefix: $custom-property-prefix,
    css-variable-name: $css-variable-name,
    local-vars: $local-vars,
    is-rtl: $is-rtl,
    nested-selectors: $nested-selectors,
    state: $state,
    media: $media,
  );

  @if $selected-function == 'default' {
    @include create-default-utility($configuration-map);
  } @else if $selected-function == 'fluid' {
    @include create-fluid-utility($configuration-map);
  } @else if $selected-function == 'custom-property-value' {
    @include create-custom-property-value-utility($configuration-map);
  } @else if $selected-function == 'simple-custom-property' {
    @include create-simple-custom-property-utility($configuration-map);
  } @else if $selected-function == 'css-var' {
    @include create-css-var-utility($configuration-map);
  } @else if $selected-function == 'responsive-custom-property' {
    @include create-responsive-custom-property-utility($configuration-map);
  }
}

@mixin create-responsive-custom-property-utility($map) {
  $responsive-custom-property: map.get($map, responsive-custom-property);
  $property: map.get($map, property);
  $important: map.get($map, important);
  $breakpoint: map.get($map, breakpoint);
  $breakpoint-key: map.get($map, breakpoint-key);
  $class: map.get($map, class);
  $key: map.get($map, key);
  $properties-length: list.length($property);

  // @debug responsive-custom-property $responsive-custom-property;
  // @debug important $important;
  // @debug breakpoint $breakpoint;
  // @debug breakpoint-key $breakpoint-key;
  // @debug class $class;
  // @debug key $key;
  // @debug properties-length $properties-length;

  @if ($properties-length > 2) {
    @error "#{$key} exceeds the maximum of 2 allowed properties. You provided #{$properties-length}.";
  }
  $breakpoint-key: if($breakpoint-key == '', $breakpoint-key, $breakpoint-key + '-');

  .#{$breakpoint}#{$class-namespace}#{$class} {
    @if ($properties-length == 2) {
      @each $prop in $property {
        #{$prop}: var(--#{$breakpoint-key}#{$responsive-custom-property}) #{$important};
      }
    } @else {
      #{$property}: var(--#{$breakpoint-key}#{$responsive-custom-property}) #{$important};
    }
  }
}

@mixin generate-pattern($pattern, $bp: '', $breakpoint-key, $key, $is-rfs-media-query: false) {
  $values: map.get($pattern, values);
  $selected-function: if(map.has-key($pattern, function), map.get($pattern, function), null);

  // Check if the list is not empty before accessing the first element
  @if list.length($values) > 0 and $values != null {
    // If the values are a list or string, convert it into a map
    @if meta.type-of($values) == 'string' or meta.type-of(list.nth($values, 1)) != 'list' {
      $values: list.zip($values, $values);
    }
  }

  // @debug values $values;
  // @debug meta.type-of($values);

  $is-important: if(map.get($pattern, important), !important, null);

  $required-property: if(
    map.has-key($pattern, required-property),
    map.get($pattern, required-property),
    null
  );
  $nesting: map.get($pattern, nesting);
  $properties: map.get($pattern, properties);

  $custom-property-value: if(
    map.has-key($pattern, custom-property-value),
    map.get($pattern, custom-property-value),
    null
  );

  // @debug $custom-property-value;
  $class: map.get($pattern, class);

  $local-vars: map.get($pattern, local-vars);
  $is-rtl: map.get($pattern, rtl);
  $custom-property-name: map.get($pattern, custom-property-name);
  $nested-selectors: if(
    map.has-key($pattern, complex-selectors),
    map.get($pattern, complex-selectors),
    null
  );
  $complex-selectors: if(
    map.has-key($pattern, complex-selectors),
    map.get($pattern, complex-selectors),
    null
  );

  $state: map.get($pattern, state);
  $custom-property-prefix: map.get($pattern, custom-property-prefix);
  $css-variable-name: map.get($pattern, css-variable-name);
  $media: map.get($pattern, media);
  $responsive-custom-props: map.get($pattern, responsive-custom-properties);

  $configuration-map: (
    nesting: $nesting,
    properties: $properties,
    responsive-custom-props: $responsive-custom-props,
    values: $values,
    important: $is-important,
    required-property: $required-property,
    breakpoint: $bp,
    breakpoint-key: $breakpoint-key,
    class: $class,
    key: $key,
    custom-property-name: $custom-property-name,
    custom-property-value: $custom-property-value,
    custom-property-prefix: $custom-property-prefix,
    css-variable-name: $css-variable-name,
    local-vars: $local-vars,
    is-rtl: $is-rtl,
    nested-selectors: $nested-selectors,
    state: $state,
    media: $media,
  );

  @if $selected-function == 'nested-rules' {
    @include create-nested-rules-pattern($configuration-map);
  } @else if $selected-function == 'property-advanced' {
    @include create-property-advanced-utility($configuration-map);
  } @else if $selected-function == 'responsive-custom-properties' {
    @include create-pattern-responsive-custom-properties($configuration-map);
  }
}

@mixin create-default-utility($map) {
  $property: map.get($map, property);
  $key: map.get($map, key);
  $values: map.get($map, values);
  $important: map.get($map, important);
  $breakpoint: map.get($map, breakpoint);
  $class: map.get($map, class);
  $local-vars: map.get($map, local-vars);
  $states: map.get($map, state);
  $states-length: if($states, list.length($states), null);
  $states: if($states-length == 1, to-list($states), $states);
  $css-var: map.get($map, css-var);
  $css-variable-name: map.get($map, css-variable-name);
  $required-property: map.get($map, required-property);
  $media: map.get($map, media);

  // @debug -------normal-utility---------------;
  // @debug media $media;

  // @debug property $property;
  // @debug values $values;
  // @debug map.get($map, class);
  // @debug required-property $required-property;
  // @debug inportant $important;
  // @debug breakpoint $breakpoint;
  // @debug key $key;
  // @debug class $class;
  // @debug state $states;
  // @debug meta-state meta.type-of($states);
  // @debug state-length $states-length;
  // @debug local-vars $local-vars;
  // @debug css-var $css-var;
  // @debug css-variable-name $css-variable-name;
  // @debug --------------------------;

  @if ($values != null) {
    @if ($states and $states-length > 1) {
      // @debug more than one state;
      @each $state in $states {
        @each $key, $value in $values {
          $key-suffix: null-safe-suffix($key);

          // @debug what type meta.type-of($breakpoint);
          // @debug breakpoint 1 $breakpoint;

          .#{$breakpoint}#{$class-namespace}#{if($class, $class, $value)}#{$key-suffix}#{$state} {
            @if $local-vars {
              @each $local-var, $value in $local-vars {
                --#{$local-var}: #{$value};
              }
            }

            @if $required-property != null {
              @each $prop, $value in $required-property {
                #{$prop}: $value #{$important};
              }
            }

            @each $p in $property {
              // @debug property $property;
              #{$p}: $value #{$important};
            }
          }
        }
      }
    } @else {
      // @debug no state;

      @each $key, $value in $values {
        $key-suffix: null-safe-suffix($key);
        $single-state: single-or-null($states);

        // @debug key $key;
        // @debug value $value;

        // @debug key-suffix $key-suffix;

        // @debug single-state $single-state;
        // @debug $breakpoint;
        // @debug meta.type-of($breakpoint);

        // @debug meta.type-of($breakpoint) == number;
        // $breakpoint: if(
        //   meta.type-of($breakpoint) == number,
        //   '\\'+ $breakpoint,
        //   $breakpoint
        // );

        // @debug new bp $breakpoint;

        .#{$breakpoint}#{$class-namespace}#{if($class, $class, $key)}#{if($class, $key-suffix, '')}#{$single-state} {
          // @debug value hier- if($class, $class, $value);

          @if $local-vars {
            @each $local-var, $value in $local-vars {
              --#{$local-var}: #{$value};
            }
          }

          @if $required-property != null {
            @each $prop, $value in $required-property {
              #{$prop}: $value #{$important};
            }
          }

          @each $property in $property {
            @if $media {
              @media #{$media} {
                #{$property}: $value #{$important};
              }
            } @else {
              #{$property}: $value #{$important};
            }
          }
        }
      }
    }
  }
}

@mixin create-fluid-utility($map) {
  $property: map.get($map, property);
  $values: map.get($map, values);
  $important: map.get($map, important);
  $breakpoint: map.get($map, breakpoint);
  $class: map.get($map, class);

  $fluid-map: $values;

  // @debug -------- fluid ----------------;
  // @debug property $property;
  // @debug type-of property meta.type-of($property);
  // @debug property string #{$property};
  // @debug #{$property} == $property;
  // @debug font-size #{$property} == 'font-size';
  // @debug values $values;
  // @debug important $important;
  // @debug breakpoint $breakpoint;
  // @debug class $class;
  // @debug breakpoint $breakpoint;
  // @debug -------------------------;

  @if ($values != null) {
    // Loop through each key in the map
    @each $key in map.keys($fluid-map) {
      $map: map.get($fluid-map, $key);
      // @debug map $map;

      $selector-suffix: $key;

      // @debug selector-suffix $selector-suffix;
      $custom-property-name: $key;

      // @debug remove-prefix remove-prefix($key, 'fs-');

      $use-custom-property: if(
        map.has-key($map, create-custom-property),
        map.get($map, create-custom-property),
        true
      );

      // @debug use $use-custom-property;
      // @debug custom-property-name $custom-property-name;
      // @debug use-custom-property $use-custom-property;

      $threshold-map: map.get($map, threshold);

      // Get keys (the viewports)
      $viewports: map.keys($threshold-map);

      $min-viewport: list.nth($viewports, 1);
      $max-viewport: list.nth($viewports, 2);

      // @debug min-viewport $min-viewport;
      // @debug max-viewport $max-viewport;

      // Get sizes
      $min-size: map.get($threshold-map, $min-viewport);
      $max-size: map.get($threshold-map, $max-viewport);

      // @debug min-size $min-size;
      // @debug max-size $max-size;

      $threshold-unit: if(
        map.has-key($map, threshold-unit),
        map.get($map, threshold-unit),
        if(#{$property} == 'font-size', 'rem', 'px')
      );
      $preferred-unit: if(map.has-key($map, preferred-unit), map.get($map, preferred-unit), 'rem');
      $relative-to: if(map.has-key($map, relative-to), map.get($map, relative-to), 'viewport');

      // @debug min-vp $min-viewport;
      // @debug max-vp $max-viewport;
      // @debug min-size $min-size;
      // @debug max-size $max-size;
      // @debug threshold-unit $threshold-unit;
      // @debug preferred-unit $preferred-unit;
      // @debug relative-to $relative-to;

      $breakpoint-prefix: breakpoint-prefix($breakpoint);
      @if ($use-custom-property) {
        // @debug inside;
        .#{$breakpoint}#{$class-namespace}#{$class}-#{$selector-suffix} {
          @each $prop in $property {
            #{$prop}: var(--#{$cp-namespace}#{$custom-property-name}) #{$important};
          }
        }
      } @else {
        .#{$breakpoint}#{$class-namespace}#{$class}-#{$selector-suffix} {
          @each $prop in $property {
            #{$prop}: fluid(
                $min-size,
                $max-size,
                $min-viewport,
                $max-viewport,
                $threshold-unit,
                $preferred-unit,
                $relative-to
              )
              #{$important};
          }
        }
      }
    }
  }
}

@mixin create-custom-property-value-utility($map) {
  $property: map.get($map, property);
  $values: map.get($map, values);
  $custom-property-trunks: if($values, map.keys($values), 'null');
  $custom-property-prefix: map.get($map, custom-property-prefix);
  $required-property: map.get($map, required-property);
  $formatted-prefix: add-hyphen($custom-property-prefix);

  $important: map.get($map, important);
  $breakpoint: map.get($map, breakpoint);
  $class: map.get($map, class);
  $local-vars: map.get($map, local-vars);
  $state: if(map.get($map, state), to-list(map.get($map, state)), null);

  // @debug property $property;
  // @debug values $values;
  // @debug required-property $required-property;
  // @debug prefix $custom-property-prefix;
  // @debug formatted-prefix $formatted-prefix;

  // @debug trunks $custom-property-trunks;

  // @debug important $important;
  // @debug breakpoint $breakpoint;
  // @debug class $class;
  // @debug state $state;

  // @debug breakpoint $breakpoint;
  // @debug local-vars $local-vars;

  @if ($values != null) {
    @if ($formatted-prefix != null) {
      @each $trunk in $custom-property-trunks {
        .#{$class-namespace}#{$class}#{$breakpoint}-#{$trunk}#{$state} {
          @if ($required-property != null) {
            @each $prop, $value in $required-property {
              #{$prop}: $value #{$important};
            }
          }
          @each $prop in $property {
            #{$prop}: var(--#{$cp-namespace}#{$formatted-prefix}#{$trunk}) #{$important};
          }
        }
      }
    } @else {
      @each $trunk, $value in $values {
        $formatted-trunk: add-hyphen(#{$trunk}, prepend);
        .#{$class-namespace}#{$class}#{$breakpoint}#{$formatted-trunk}#{$state} {
          @if ($required-property != null) {
            @each $prop, $value in $required-property {
              #{$prop}: $value #{$important};
            }
          }
          @each $prop in $property {
            #{$prop}: $value #{$important};
          }
        }
      }
    }
  }
}

@mixin create-property-advanced-utility($map) {
  $properties: map.get($map, properties);
  $values: map.get($map, values);
  $important: map.get($map, important);
  $breakpoint: map.get($map, breakpoint);
  $class: map.get($map, class);
  $local-vars: map.get($map, local-vars);
  $states: map.get($map, state);
  $states-length: if($states, list.length($states), null);
  $states: if($states-length == 1, to-list($states), $states);
  // @debug properties $properties;
  // @debug important $important;
  // @debug breakpoint $breakpoint;
  // @debug class $class;
  // @debug state $states;
  // @debug state-length $states-length;
  // @debug meta-state meta.type-of($states);
  // @debug local-vars $local-vars;
  // @debug join list.join($states, (), comma);
  // @debug states $states;
  // @debug length $states-length;

  @if ($states and $states-length > 1) {
    $formatted-states: list.join($states, (), comma);
    // @debug $formatted-states;

    .#{$breakpoint}#{$class-namespace}#{$class}:where(#{$formatted-states}) {
      @each $prop, $value in $properties {
        #{$prop}: $value #{$important};
      }
    }
  } @else {
    // Get single state from $states list, returns null if unset
    $single-state: single-or-null($states);

    .#{$breakpoint}#{$class-namespace}#{$class}#{$single-state} {
      @each $prop, $value in $properties {
        #{$prop}: $value #{$important};
      }
    }
  }
}

@mixin create-pattern-responsive-custom-properties($map) {
  $responsive-custom-props: map.get($map, responsive-custom-props);
  $important: map.get($map, important);
  $breakpoint: map.get($map, breakpoint);
  $breakpoint-key: map.get($map, breakpoint-key);
  $class: map.get($map, class);

  // @debug responsive-custom-props $responsive-custom-props;
  // @debug important $important;
  // @debug breakpoint $breakpoint;
  // @debug breakpoint-key $breakpoint-key;
  // @debug class $class;

  $breakpoint-key: if($breakpoint-key == '', $breakpoint-key, $breakpoint-key + '-');

  .#{$breakpoint}#{$class-namespace}#{$class} {
    @each $prop, $value in $responsive-custom-props {
      #{$prop}: var(--#{$breakpoint-key}#{$value}) #{$important};
    }
  }
}

@mixin create-nested-rules-pattern($map) {
  $nesting: map.get($map, nesting);
  $values: map.get($map, values);
  $important: map.get($map, important);
  $breakpoint: map.get($map, breakpoint);
  $class: map.get($map, class);

  // @debug nesting $nesting;
  // @debug important $important;
  // @debug breakpoint $breakpoint;
  // @debug class $class;
  // @debug values $values;

  // @debug meta.type-of($values);

  @if ($values != null and meta.type-of($values) == map) {
    @each $key, $value in $values {
      .#{$breakpoint}#{$class}-#{$key} {
        @each $property, $property-value in $nesting {
          // @debug property $property;
          // @debug property-value $value;

          @if meta.type-of($property-value) == 'map' {
            $_nested-selector: $property;

            #{$_nested-selector} {
              @each $nested-property, $nested-value in $property-value {
                $formatted_value: null;

                @if ($nested-value == '') {
                  $formatted_value: '""';
                } @else if($nested-value == VALUE) {
                  $formatted_value: $value;
                } @else {
                  $formatted_value: $nested-value;
                }

                #{$nested-property}: #{$formatted_value};
              }
            }
          } @else {
            #{$property}: #{$value};
          }
        }
      }
    }
  } @else {
    .#{$breakpoint}#{$class} {
      // Loop through the nesting defined for each utility
      @each $property, $property-value in $nesting {
        @if meta.type-of($property-value) == 'map' {
          $_nested-selector: $property;

          #{$_nested-selector} {
            @each $nested-property, $nested-value in $property-value {
              $formatted_value: if($nested-value == '', '""', $nested-value);
              #{$nested-property}: #{$formatted_value} #{$important};
            }
          }
        } @else {
          #{$property}: #{$property-value} #{$important};
        }
      }
    }
  }
}

@mixin create-css-var-utility($map) {
  $property: map.get($map, property);
  $key: map.get($map, key);
  $values: map.get($map, values);
  $important: map.get($map, important);
  $breakpoint: map.get($map, breakpoint);
  $class: if(map.get($map, class) != null, map.get($map, class), $key);
  $local-vars: map.get($map, local-vars);
  $states: map.get($map, state);
  $states-length: if($states, list.length($states), null);
  $states: if($states-length == 1, to-list($states), $states);
  $css-variable-name: map.get($map, css-variable-name);
  $custom-property-trunks: if($values, map.keys($values), 'null');
  $custom-property-prefix: map.get($map, custom-property-prefix);

  // @debug --------------------------;
  // @debug property $property;
  // @debug custom-property-trunks $custom-property-trunks;
  // @debug custom-property-prefix $custom-property-prefix;
  // @debug values $values;
  // @debug inportant $important;
  // @debug breakpoint $breakpoint;
  // @debug key $key;
  // @debug class $class;
  // @debug state $states;
  // @debug meta-state meta.type-of($states);
  // @debug state-length $states-length;
  // @debug local-vars $local-vars;
  // @debug css-variable-name $css-variable-name;
  // @debug --------------------------;

  @if ($values != null) {
    @if ($states and $states-length > 1) {
      // @debug more than one state;
      @each $state in $states {
        @each $key, $value in $values {
          $key-suffix: null-safe-suffix($key);
          // @debug key-suffix $key-suffix;

          @if ($custom-property-prefix) {
            .#{$class-namespace}#{$class}#{$breakpoint}#{$key-suffix}#{$state} {
              --#{$css-variable-name}: var(
                --#{$cp-namespace}#{$custom-property-prefix}#{$key-suffix}
              );
            }
          } @else {
            .#{$class-namespace}#{$class}#{$breakpoint}#{$key-suffix}#{$state} {
              --#{$css-variable-name}: #{$value};
            }
          }
        }
      }
    } @else {
      @each $key, $value in $values {
        $key-suffix: null-safe-suffix($key);
        // @debug key $key;
        // @debug key-suffix $key-suffix;
        $single-state: single-or-null($states);
        // @debug $single-state;
        @if ($custom-property-prefix) {
          .#{$class-namespace}#{$class}#{$breakpoint}#{$key-suffix}#{$single-state} {
            --#{$css-variable-name}: var(
              --#{$cp-namespace}#{$custom-property-prefix}#{$key}#{$single-state}
            );
          }
        } @else {
          // @debug single-state $single-state;
          .#{$class-namespace}#{$class}#{$breakpoint}#{$key-suffix}#{$single-state} {
            --#{$css-variable-name}: #{$value};
          }
        }
      }
    }
  }
}

@mixin create-simple-custom-property-utility($map) {
  // @debug map $map;
  // @debug keys map.keys($map);
  // @debug HEER $map;

  $map: map.get($map, values);

  @if $map != null {
    @if list.length(map.keys($map)) > 0 {
      @each $key, $value-map in $map {
        // @debug key $key;
        // @debug value-map $value-map;

        $_class: if(map.has-key($value-map, class), map.get($value-map, class), $key);
        $_property: map.get($value-map, property);

        @if ($_property) {
          .#{$_class} {
            #{$_property}: var(--#{$cp-namespace}#{$key});
          }
        }
      }
    }
  }
}

@mixin generate-responsive-custom-properties($map, $local-namespace: '') {
  // @debug map $map;
  // @debug bps map.keys($map);
  $_prefix: if(string.length($local-namespace) > 0, $local-namespace + '-', '');

  @each $breakpoint in map.keys($map) {
    // @debug bp $breakpoint;

    @include media-breakpoint-up($breakpoint) {
      // @debug inside media-bp-up $breakpoint;

      @if ($breakpoint == 'xs') {
        // @debug map map.get($map, $breakpoint);
        @each $custom-property-name, $value-object in map.get($map, $breakpoint) {
          // @debug custom-property-name $custom-property-name;
          // @debug value-object $value-object;
          // @debug ----------;
          --#{$cp-namespace}#{$_prefix}#{$custom-property-name}: #{map.get($value-object, value)};
        }
      } @else {
        @each $custom-property-name, $value in map.get($map, $breakpoint) {
          // @debug in else;
          // @debug custom-property-name $custom-property-name;
          // @debug value $value;

          // @debug ----------;

          & {
            --#{$cp-namespace}#{$_prefix}#{$custom-property-name}: #{$value};
          }
        }
      }
    }
  }
}

@mixin generate-custom-properties($map: (), $local-namespace: '') {
  @if $map != null {
    @if map.has-key($map, custom-property-prefix) {
      $_name: map.get($map, custom-property-prefix);
      $_map: map.get($map, values);
      // @debug map 1 $_map;

      // convert to a map if $_map is a list
      $_map: if(meta.type-of($_map) == list, list.zip($_map, $_map), $_map);
      // @debug _name $_name;
      // @debug _map 2 $_map;

      @if $_map {
        @each $key, $value in $_map {
          // @debug key $key;
          // @debug value $value;

          @if ($key != 'none') {
            $_key: if($key != null, if($key == 0, '-0', -$key), '');
            --#{$cp-namespace}#{$local-namespace}#{$_name}#{$_key}: #{$value};
          }
        }
      }
    } @else if(map.has-key($map, xs)) {
      @each $key, $value in $map {
        @if $key != xs {
          --#{$cp-namespace}#{$local-namespace}#{$key}: #{$value};
        }
      }
    }
  }
}

@mixin generate-simple-custom-properties($map: ()) {
  @if ($map != null) {
    @if list.length(map.keys($map)) > 0 {
      @each $key, $value in $map {
        @if (meta.type-of($value) == map) {
          --#{$cp-namespace}#{$key}: #{map.get($value, value)};
        } @else {
          --#{$cp-namespace}#{$key}: #{$value};
        }
      }
    }
  }
}
@mixin generate-clamp-custom-properties(
  $clamp-map,
  $default-unit: 'rem',
  $default-relative-to: 'viewport'
) {
  // Only loop if the map has entries
  @if ($clamp-map != null and list.length(map.keys($clamp-map)) > 0) {
    @each $key, $map in $clamp-map {
      $has-custom-property: if(
        map.has-key($map, create-custom-property),
        map.get($map, create-custom-property),
        true
      );

      @if ($has-custom-property) {
        $relative-to: if(
          map.has-key($map, relative-to),
          map.get($map, relative-to),
          $default-relative-to
        );

        $threshold-unit: if(
          map.has-key($map, threshold-unit),
          map.get($map, threshold-unit),
          $default-unit
        );

        $threshold-keys: map.keys(map.get($map, threshold));
        $threshold-map: map.get($map, threshold);

        $min-size: map.get($threshold-map, list.nth($threshold-keys, 1));
        $max-size: map.get($threshold-map, list.nth($threshold-keys, 2));

        // convert the keys to its corresponding pixel value. Otherwise, use the value as-is.
        $key-min-formatted: if(
          meta.type-of(list.nth($threshold-keys, 1)) ==
            'string' and
            map.has-key($grid-breakpoints, list.nth($threshold-keys, 1)),
          map.get($grid-breakpoints, list.nth($threshold-keys, 1)),
          list.nth($threshold-keys, 1)
        );
        $key-max-formatted: if(
          meta.type-of(list.nth($threshold-keys, 2)) ==
            'string' and
            map.has-key($grid-breakpoints, list.nth($threshold-keys, 2)),
          map.get($grid-breakpoints, list.nth($threshold-keys, 2)),
          list.nth($threshold-keys, 2)
        );

        $min-viewport: remove-unit-and-convert($key-min-formatted);
        $max-viewport: remove-unit-and-convert($key-max-formatted);

        $delta-size: $max-size - $min-size;
        $delta-viewport: $max-viewport - $min-viewport;
        $change: round-to(math.div($delta-size, $delta-viewport), 6);

        $preferred: round-to(math.div($max-size - ($max-viewport * $change), 16) * 1rem, 4);

        $rate-of-change: null;

        @if $relative-to == 'viewport' {
          $rate-of-change: round-to(100vw * $change);
        } @else if $relative-to == 'container' {
          $rate-of-change: round-to(100cqi * $change);
        } @else {
          @error 'Invalid value for $relativeTo. Expected "viewport" or "container".';
        }

        $min-size: if($threshold-unit == 'rem', px-to-rem($min-size), $min-size * 1px);
        $max-size: if($threshold-unit == 'rem', px-to-rem($max-size), $max-size * 1px);

        --#{$cp-namespace}#{$key}: clamp(
          #{$min-size},
          calc(#{$preferred} + #{$rate-of-change}),
          #{$max-size}
        );
      }
    }
  }
}

@mixin generate-clamp-custom-properties_og(
  $clamp-map,
  $clamp-prefix: '',
  $relative-to: 'viewport',
  $threshold-unit: 'px',
  $unit: 'px'
) {
  // @debug unit $unit;

  @each $key, $map in $clamp-map {
    // @debug map $map;

    $threshold: map.keys($map);
    // @debug th $threshold;
    $sizeMin: map.get($map, list.nth($threshold, 1));
    $sizeMax: map.get($map, list.nth($threshold, 2));

    // @debug list 1 list.nth($threshold, 1);
    // @debug list 2 list.nth($threshold, 2);

    // @debug sizeMin $sizeMin;
    // @debug sizeMax $sizeMax;

    // $viewportMin: remove-unit-and-convert(
    //   map.get($grid-breakpoints, list.nth($threshold, 1))
    // );
    // $viewportMax: remove-unit-and-convert(
    //   map.get($grid-breakpoints, list.nth($threshold, 2))
    // );

    $viewportMin: remove-unit-and-convert(list.nth($threshold, 1));
    $viewportMax: remove-unit-and-convert(list.nth($threshold, 2));

    // @debug viewportMin $viewportMin;
    // @debug viewportMax $viewportMax;

    $deltaSize: $sizeMax - $sizeMin;
    $deltaViewport: $viewportMax - $viewportMin;
    $change: round-to(math.div($deltaSize, $deltaViewport), 6);

    // @debug change $change;
    // @debug $change * 100vw;

    // $preferred: round-to($sizeMax - ($viewportMax * $change), 4) * 1px;
    $preferred: if(
      $unit == 'rem',
      round-to(math.div($sizeMax - ($viewportMax * $change), 16) * 1rem, 4),
      round-to($sizeMax - ($viewportMax * $change), 4) * 1px
    );

    $rateOfChange: null;

    @if $relative-to == 'viewport' {
      $rateOfChange: round-to(100vw * $change);
    } @else if $relative-to == 'container' {
      $rateOfChange: round-to(100cqi * $change);
    } @else {
      @error 'Invalid value for $relativeTo. Expected "viewport" or "container".';
    }

    $sizeMin: if($threshold-unit == 'rem', px-to-rem($sizeMin), $sizeMin * 1px);
    $sizeMax: if($threshold-unit == 'rem', px-to-rem($sizeMax), $sizeMax * 1px);

    --#{$cp-namespace}#{$clamp-prefix}#{$key}: clamp(
      #{$sizeMin},
      calc(#{$preferred} + #{$rateOfChange}),
      #{$sizeMax}
    );
  }
}

@mixin generate-color-themes($color-theme, $removed-theme: 'default') {
  // @debug color-theme $color-theme;
  // @debug meta.type-of($color-theme);

  $_theme-map: map.remove($color-theme, $removed-theme);
  // @debug _theme-map $_theme-map;
  // @debug meta meta.type-of($_theme-map);

  @each $theme, $color-map, $color-hover in $_theme-map {
    $colors: map.get($color-map, color);
    $colors-hover: if(map.get($color-map, hover) != null, map.get($color-map, hover), ());
    // @debug theme $theme;
    // @debug color $colors;
    // @debug color-hover $colors-hover;

    [data-theme='#{$theme}'] {
      $colors-rgb: map-loop($colors, to-rgb, '$value');
      @include generate-color-custom-properties($colors, $color-prefix);
      @include generate-color-custom-properties-rgb($colors-rgb, $color-prefix);
      @include generate-color-custom-properties($colors-hover, $hover-prefix);
    }
  }
}

@mixin generate-color-custom-properties($color-theme, $color-prefix: 'clr-') {
  // @debug meta.type-of($color-theme);

  @each $color-name, $value in $color-theme {
    @if (meta.type-of($value) == 'color') {
      --#{$cp-namespace}#{$color-prefix}#{$color-name}: #{$value};
    } @else {
      @error 'the color input is not correct';
    }
  }
}

@mixin generate-color-custom-properties-rgb($color-theme-map: (), $color-prefix: 'clr-') {
  // Only loop if the map has entries

  // @debug MAPP $color-theme-map;
  @if $color-theme-map != null and list.length(map.keys($color-theme-map)) > 0 {
    @each $color, $rgb-value in $color-theme-map {
      $type: meta.type-of($rgb-value);

      @if ($type == 'list') {
        // @debug color $color;
        // @debug rgb $rgb-value;

        --#{$cp-namespace}#{$color-prefix}#{$color}-rgb: #{$rgb-value};
      } @else {
        @error 'the color input is not correct';
      }
    }
  }
}

@mixin export-breakpoints-json($grid-breakpoints, $prop-name: --js-breakpoints) {
  $json: '{';
  $i: 0;
  $len: list.length($grid-breakpoints);
  $last-item-index: $len - 1;
  @each $key, $val in $grid-breakpoints {
    // Zahl in px ohne Einheit schreiben
    @if ($key != xs) {
      @if (math.is-unitless($val)) {
        @error 'your breakpoint: #{$key}:#{$val} is unitless!';
      }

      // @debug val $val;
      // @debug meta.type-of($val);
      $json: $json + '"' + $key + '":' + '"' + $val + '"';

      @if $i != $last-item-index {
        $json: $json + ',';
      }
    }

    $i: $i + 1;
  }

  $json: $json + '}';
  // $json: string.unquote($json);

  #{$prop-name}: '#{$json}';
}
